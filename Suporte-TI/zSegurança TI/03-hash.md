# Geração de hash

**Hashing ou função hash é um tipo de função ou operação que toma dados arbitrários e os mapeia em um resultado de tamanho fixo chamado de valor hash ou checksum.** O tamanho do resultado é geralmente especificado em bits de dados e é frequentemente incluído no nome da função de hash. O que você faz é inserir qualquer quantidade de dados em uma função hash e o resultado é sempre do mesmo tamanho. Mas o resultado deve ser exclusivo para determinada entrada, de forma que duas entradas diferentes nunca podem produzir o mesmo resultado. As funções hash têm um grande número de aplicações na computação em geral, sendo usados para identificar dados de forma exclusiva.

A função hash também pode ser usada para identificar conjuntos de dados duplicados em bancos de dados ou arquivos para acelerar a busca de tabelas ou para remover dados duplicados para economizar espaço. Dependendo da aplicação, existem várias propriedades que podem ser aproveitadas e há diversas funções hash para várias aplicações.

Nosso foco é principalmente as funções hash criptográficas que são usadas para várias aplicações, como autenticação, integridade de mensagens, impressão digital, detecção de corrupção de dados e assinaturas digitais. A função hash criptográfica é diferente da criptografia porque as funções hash criptográficas devem ser unidirecionais.
Por exemplo, você pode inserir um texto simples na função hash e obter um resultado ininteligível, mas você não pode pegar o resultado hash e recuperar o texto simples.

A função hash criptográfico deve ser determinista, ou seja, o mesmo valor de entrada deve sempre retornar o mesmo valor hash. A função deve ser rápida e eficiente de calcular. Deve ser inviável reverter a função e recuperar o texto simples a a partir do valor hash. Uma pequena mudança na informação de entrada deve resultar em uma mudança no resultado, de forma que não haja correlação entre a mudança na entrada a mudança que ocorre no resultado.

Por fim, **a função não deve permitir colisões de hash, ou seja, duas diferentes entradas mapearem para o mesmo resultado.** As funções hash criptográficas são semelhantes à cifras de bloco de chave simétrica e operam em blocos de dados. De fato, muitas funções hash populares são, na verdade, baseadas em cifras de bloco modificadas.

`$ echo "Hello World | md5sum"`
gerará um HASH

`$ echo "hello world | md5sum`
gerará outro valor de hash

## Algoritmos de geração de hash

O MD5 é uma função hash popular e amplamente utilizada criada no início dos anos 90 como função hash criptográfica. Ele opera em blocos de 512 bits e gera valores hash de 128 bits. O MD5 foi publicado em 1992, mas uma falha de projeto foi descoberta em 1996, e os criptógrafos recomendaram o uso do hash **SHA-1, uma alternativa mais segura.** Mas essa falha não foi considerada crítica e a função hash continuou sendo amplamente usada e adotada.

Em 2004, descobriu-se que o MD5 era suscetível a colisões de hash, possibilitando a criação de um arquivo prejudicial para gerar o mesmo valor hash MD5 para outro arquivo diferente. Logo depois que essa falha foi descoberta, pesquisadores de segurança conseguiram gerar dois arquivos diferentes com a valores hash MD5 correspondentes. Em 2008, pesquisadores de segurança deram um passo adiante e comprovaram a possibilidade de criar um certificado SSL falso que era validado devido a uma colisão de hash no MD5. Em razão dessas vulnerabilidades sérias na função hash, **recomendou-se a suspensão do MD5 para aplicativos criptográficos até 2010.**

Em 2012, essa colisão hash foi usada para finalidades sombrias no malware _flame_, que usou um certificado digital Microsoft forjado para assinar seu malware, o que fez com o malware parecesse software legítimo da Microsoft.

Quando as falhas de projeto foram descobertas no MD5, recomendou-se o uso do SHA-1 como substituto. **O SHA-1 faz parte do conjunto de algoritmos seguros de funções hash criado pela NSA e publicado em 1995.** Ele opera em blocos de 512 bits e gera valores hash de 160 bits. O SHA-1 é outra função hash criptográfica amplamente usada em protocolos populares como **TLS/SSL, PGP SSH e IPsec.** O SHA-1 também é usado em sistemas de controle de versões como o **Git**, que usa hashs para identificar revisões garantir a integridade dos dados por meio da detecção de corrupção ou adulteração.

O SHA-1 e o SHA-2 foram exigidos em alguns casos do governo dos EUA para proteção de informações confidenciais. Embora o Instituto Nacional de Padrões e Tecnologia dos EUA tenha recomendado a suspensão do SHA-1 e a adoção do SHA-2 em 2010, muitas outras organizações também recomendaram a substituição do SHA-1 pelo SHA-2 ou pelo SHA-3. Grandes fornecedores de navegadores anunciaram intenções de interromper o suporte a certificados SSL que usassem o SHA-1 em 2017.

O SHA-1 também tem seus pontos fracos e vulnerabilidades, e os pesquisadores de segurança já tentaram demonstrar a existência de colisões hash. Na primeira década do século, um monte de ataques teóricos foram formulados e algumas colisões parciais foram demonstradas, mas colisões completas usando esses métodos exigem um poder computacional muito grande. Um desses ataques pode ter custado US$ 2,77 milhões em recursos de CPU para computação em nuvem.

Em 2015, um método de ataque diferente foi desenvolvido e não demonstrou nenhuma colisão completa, mas foi a primeira vez que um desses ataques comprovadamente teve implicações importantes para a segurança do SHA-1. O que era possível antes só na teoria agora estava se tornando possível com métodos de ataque mais eficientes e com o aumento no desempenho da computação, especialmente na área de cálculos acelerados por GPU em recursos na nuvem. Estima-se que uma colisão completa com este método de ataque seja viável com computação em nuvem de CPU e GPU de US$ 75 mil a US$ 120 mil, muito mais barata que a dos ataques anteriores.

No início de 2017, a primeira colisão total no SHA1 foi publicada. Usando recursos significativos de CPU e GPU, foram criados dois arquivos PDF exclusivos que resultaram no mesmo hash SHA-1. O poder de processamento estimado necessário foi descrito como o equivalente a 6.500 anos de uma única CPU e 110 anos ininterruptos de uma única GPU. São muitos anos. Há também o conceito de MIC, ou verificação de integridade da mensagem. Não confunda com a reificação de autenticação de mensagem, ou MAC, porque o funcionamento a forma de proteção são diferentes. O MIC é basicamente um valor hash da mensagem em questão. É uma espécie de soma de verificação para a mensagem, garantindo que o conteúdo da mensagem não tenha sido modificado durante o percurso. Mas é muito diferente do MAC sobre o qual falamos anteriormente. Ele não usa chaves secretas, o que significa que a mensagem não é autenticada. Não há nada que impeça um invasor de alterar a mensagem recalculando a soma de verificação e modificando o MIC anexado a ela. Os MICs são uma proteção contra corrupção ou perda acidentais, mas eles não protegem contra adulteração ou ações prejudiciais.

Uma aplicação crucial das funções hash criptográficas é a autenticação.
No contexto da autenticação, teríamos que armazenar em algum lugar senhas de usuários em texto simples. Essa é uma péssima ideia. Nunca se deve armazenar informações confidenciais, como senhas, em texto simples. Em vez disso, deve-se fazer o que praticamente todo sistema de autenticação faz: **armazenar um hash da senha em vez da própria senha. Quando você entra em sua conta de e-mail, a senha que você digitou é passada por uma função hash e o valor hash resultante é comparado com o hash que consta no arquivo.** Se os hashes coincidirem, sabemos que a senha está correta e você será autenticado.

A senha não deve ser armazenada em texto simples, porque se os sistemas ficarem vulneráveis, as senhas das outras contas serão alvos fáceis para invasores. Se um invasor obtiver acesso ao seu sistema e conseguir copiar o banco de dados de contas e senhas, teríamos evidentemente uma situação muito ruim. Ao armazenar apenas hashes das senhas, o máximo que o invasor conseguiria recuperar seria os hashes, que não teriam utilidade nenhuma sozinhos.

E se o invasor quisesse descobrir quais senhas correspondem aos hashes que eles roubaram? Eles fariam um ataque de força bruta contra o banco de dados de hashes de senhas. É aqui que o invasor tentaria todas as entradas possíveis até que o hash resultante correspondesse ao que eles estão tentando recuperar. Se houvesse uma correspondência, saberíamos que a respectiva entrada corresponderia à senha oculta. Um ataque de força bruta pode ser extremamente exigente em termos de computação, dependendo da função hash usada. Uma característica importante sobre os ataques de força bruta é que, tecnicamente, não há como se proteger contra eles totalmente. Um ataque de força bruta exitoso até mesmo contra o sistema mais seguro que se possa imaginar é uma questão de tempo e de recursos do invasor. **Se um invasor tiver tempo e/ou recursos ilimitados, qualquer sistema pode sofrer ataques de força bruta.**

O melhor que podemos fazer para nos protegermos contra esses ataques é criar mais obstáculos, fazer com que o tempo e recursos necessários sejam algo praticamente inviável pelo tempo exigido ou pela tecnologia existente.

Outro método comum para aumentar os obstáculos computacionais e se proteger contra os ataques de força bruta é passar a senha pela função hash várias vezes, às vezes milhares de vezes. Isso exigiria muito mais cálculos para cada tentativa de descoberta da senha. Isso nos leva ao assunto _rainbow tables_. Essas tabelas são usadas por meliantes para acelerar o processo de recuperação de senhas a partir de hashes roubados. Uma rainbow table nada mais é que uma tabela pré-computada de todos os possíveis valores de senha e seus hashes correspondentes. A ideia por trás dos ataques com rainbow table é trocar poder computacional por espaço em disco fazendo uma pré-computação dos hashes e armazenando-os em uma tabela. O invasor pode determinar qual é a senha correspondente para determinado hash pesquisando o hash na rainbow table.

A diferença para um ataque de força bruta é que o hash é calculado para cada tentativa de adivinhação. É possível baixar rainbow tables da Internet com listas de senhas e funções hash mais comuns. Assim, reduz-se ainda mais a necessidade de recursos computacionais que exigem grandes quantidades de espaço para guardar todos os dados de senhas e de hashes. Você pode estar se perguntando como se proteger dessas rainbow tables pré-computadas. Um sal é um dado aleatório adicional que se acrescenta a uma função hash para gerar um hash exclusivo para aquela combinação de senha e sal. Um sal de alta numeração escolhido aleatoriamente é concatenado ou colado no fim da senha. A combinação de sal e senha é passada na função hash para gerar o hash, que fica armazenado junto com o sal. Isso significa que o invasor teria que calcular uma rainbow table para cada valor de sal possível. Se o sal for muito grande, os requisitos computacionais e de armazenamento para gerar rainbow tables úteis tornam-se praticamente inviáveis.

Os primeiros sistemas Unix usavam um sal de 12 bits, o que totaliza 4.096 sais possíveis. Assim, para cada senha da sua base de dados, o invasor teria que gerar hashes 4.096 vezes. Os sistemas modernos como o Linux, BSD e Solaris usam um sal de 128 bits. Isso significa os valores possíveis de sal são 2 elevado a 128, o que dá mais de 340 undecilhões. É 340 e mais 36 zeros. Claramente, o sal de 128 bits cria obstáculos suficientes para que um ataque com rainbow tables seja impossível em um período de tempo realista. É só mais uma situação em que colocar sal deixa algo melhor.
